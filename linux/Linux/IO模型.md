# I/O 模型

### 内核空间、用户空间
操作系统的核心是内核，独立于其他应用程序，可以访问底层会保护的硬件，Linux为了防止用户进程直接操作内核，将虚拟地址空间，分成用户空间和内核空间，用户空间就是用户进程所在的空间

### 进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的

从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：

1. 保存处理机上下文，包括程序计数器和其他寄存器
2. 更新PCB信息
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列
4. 选择另一个进程执行，并更新其PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文


### 进程的阻塞
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。
可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程(获得CPU)，才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。

### 进程缓存区、内核缓冲区
缓冲区的出现是为了减少频繁的系统调用，由于系统调用需要保存之前的进程数据和状态等信息，而结束调用之后回来还需要回复之前的信息，为了减少这种耗时耗性能的调用于是出现了缓冲区。
在Linux系统中，每个进程有自己独立的缓冲区，叫做进程缓冲区，而系统内核也有个缓冲区叫做内核缓冲区

操作系统使用 read 函数把数据从内核缓冲区复制到进程缓冲区，write 把数据从进程缓冲区复制到内核缓冲中


### 文件描述符 fd
文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引入的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表
当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开


## Linux/Unix 5种IO模型
当一个IO发生时候的，涉及到的步骤和对象

以网络socket 的 read 为例子

涉及到的对象

- 一个是调用这个 IO 的 process(or thread) (用户进程)
- 一个就是系统内核(kernel)

经历的步骤

- 等待数据准备，比如 accept()，recv()等待数据
- 将数据从内核拷贝到进程中，比如 accept() 接受到请求，recv()接收连接发送的数据后需要复制到内核，再从内核复制到进程用户空间

### 阻塞IO

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。
这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。
当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

### 非阻塞IO

当用户进程发出 read 操作时，如果 kernel 中的数据还没准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。
用户进程判断结果是一个error时，它就知道数据还没准备好，于是它可以再次发送read操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回



































































