# MySQL

### 事务的四大特性(ACID)
1. 原子性
2. 一致性
3. 隔离性
4. 持久性

### MySQL 事务的隔离级别
> MySQL 默认是可重复度
1. 读取未提交读
2. 读取提交读
3. 可重复读
4. 可串行化


| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :---: | :---: | :---: | :---: |
|读未提交（read-uncommitted） | 是 | 是 | 是 |
|不可重复读（read-committed） | 否 | 是 | 是 |
|可重复读（repeatable-read） | 否 | 否 | 是 |
|串行化（serializable） | 否 | 否 | 否 |

### 事务并发问题

1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
> 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

### SQL 语句问题

判断是否使用索引：explain

| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra|
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |


- #### id：决定表的读取数据

执行select语句查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序

它有三种情况：
1. id相同，执行顺序由上至下
2. id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
3. id相同不同，同时存在，如果id相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行；


- #### select_type：查询的类型，也就是数据读取操作的操作类型，

它一共有以下5种
1. simple：简单的select查询，查询中不包含子查询或者union
2. primary：查询中若包含任何复杂的子查询，最外层的查询则被标记
3. subquery：在select或者where列表中包含了子查询
4. derived：在from列表中包含的子查询被标记为DERIVED(衍生表)，MySQL会递归执行这些子查询，把结果放临时表中
5. union：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：DERIVED
6. union result：从union表(即union合并的结果集)中获取select查询的结果


- #### type：访问类型排列  
 
显示查询使用了何种类型，从最好到最差依次是：system > const > eq_ref > ref > rage > index > all

system：表只有一行记录(等于系统表)，这是const类型的特例，平时不会出现，这个也可忽略不计

const：表示通过索引一次就找到了，const用于比较primary key 或者 unique 索引。因为只匹配一行记录，所以很快。

eq_ref：唯一性索引扫描，对于每一个索引键，表中只有一条记录与之匹配，常用于逐渐或者唯一索引扫描

ref：非唯一性索引扫描，返回匹配某个单独值得所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件
的行，所以它应该属于查找和扫描的混合体

range：只检索给定范围的行，使用一个索引来选择行，key列显示使用哪个索引，一般就是在你的where语句中出现了between、<、>、in 等的查询；
这种范围索引扫描比全表扫描要好，因为它只需要开始于索引的某一个点，结束于另一个点，不用扫描全部索引；

index：index于all区别为index类型只遍历索引树，这通常比all快，因为索引文件通常比数据文件小，也就是说虽然all和index都是读写表，但index是
从索引中读取的，而all是从硬盘中读的

all：也就是全盘扫描
> 备注：一般来说，得保证查询至少达到range级别，最好能达到ref


- #### possible_keys
显示可能会被应用到这张表的索引，一个或者多个，查询涉及到的字段上，若存在索引，则该索引将被列出，但不一定被查询实际使用到

 
- #### key：
实际使用到的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中


- #### key_len
表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精准性的情况下，长度越短越好；key_len显示的值为索引字段的最大的可能长度
并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的

- ### ref
显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量别用于查找索引列上的值

- ### rows
根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

- ### Extra：包含不适合在其他列中显示但十分重要的额外信息：
1. using filesort(出现这个东西不好)：说明mysql会被数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，mysql中无法利用
索引完成的排序操作称为'文件排序'

2. using temporary(出现这个东西更不好,使用到了临时表)：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表，常见于排序order by
和分组查询 group by

3. using index：表示相应的select操作中使用了覆盖索引(Covering Index)，避免了访问了表的数据行，效率不错！



































