# Redis

### 数据类型
    String(字符串)
    Hash(哈希)
    List(列表)
    Set(集合)
    Zset(有序集合)
    
### 两种永久化机制
> RDB

    RDB是将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。
    优点：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能
    缺点：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

> AOF

    AOF是将执行过的指令记录下来，数据恢复时按照从前到后的顺序再将指令执行一遍，实现数据恢复
    优点：可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据；且如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）。
    缺点：AOF文件比RDB文件大，且恢复速度慢。
    
### Redis和Memcache区别，优缺点对比
redis和memecache的不同在于：
1. 存储方式：
memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小
redis有部份存在硬盘上，这样能保证数据的持久性。
2. 数据支持类型：
redis在数据支持上要比memecache多的多。
3. 使用底层模型不同：
新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4. 运行环境不同：
redis目前官方只支持LINUX 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。但是没有放到主干上


### Redis和mysql数据怎么保持数据一致的

#### 第一种方案：采用延时双删策略

具体步骤是：
1. 先删除缓存
2. 再写数据库
3. 休眠500毫秒
4. 再次删除缓存

该方案的弊端：

结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。


#### 第二种方案：异步更新缓存(基于订阅binlog的同步机制)

技术整体思路：

1. 读Redis：热数据基本都在Redis
2. 写MySQL:增删改都是操作MySQL
3. 更新Redis数据：MySQ的数据操作binlog，来更新到Redis

> 消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!

### 缓存过期策略

- noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。

- allkeys-lru：在主键空间中，优先移除最近未使用的key。

- volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。

- allkeys-random：在主键空间中，随机移除某个key。

- volatile-random：在设置了过期时间的键空间中，随机移除某个key。

- volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。
















